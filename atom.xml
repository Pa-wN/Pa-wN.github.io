<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xuan</title>
  
  <subtitle>路漫漫其修远兮</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-24T18:44:45.514Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实现call，apply，bind，new</title>
    <link href="http://yoursite.com/2018/04/25/%E5%AE%9E%E7%8E%B0call%EF%BC%8Capply%EF%BC%8Cbind%EF%BC%8Cnew/"/>
    <id>http://yoursite.com/2018/04/25/实现call，apply，bind，new/</id>
    <published>2018-04-24T18:31:51.000Z</published>
    <updated>2018-04-24T18:44:45.514Z</updated>
    
    <content type="html"><![CDATA[<ul><li>模仿<code>call</code>的实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype._call = function (context) &#123;</span><br><span class="line">  // 传入的this值为null或者为空的时候</span><br><span class="line">  var context = context || window;</span><br><span class="line"></span><br><span class="line">  var args = [];</span><br><span class="line">  for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    args.push(&apos;arguments[&apos; + i + &quot;]&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  var res = eval(&apos;context.fn(&apos;+ args +&apos;)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><blockquote><ul><li>要实现call的功能主要在于把函数的this指向我们想要的对象上<br>把函数赋值给要指向的对象的一个属性，然后再调用就该属性。</li><li>接着用<code>eval</code>的方式调用该函数，以达到参数的正确传递。<br>类似于 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- apply的实现 (实现类似call)</span><br></pre></td></tr></table></figure></li></ul></blockquote><pre><code>Function.prototype._apply = function (context, arr) {  // 传入的this值为null或者为空的时候  var context = context || window;  context.fn = this;  var res;  if (!arr) {    res = context.fn();  }  else {    var args = [];    for (var i = 0; i &lt; arr.length; i++) {      (function (i) {        args.push(&apos;arr[&apos; + i + &apos;]&apos;);      })(i)    }    var res = eval(&apos;context.fn(&apos;+ args +&apos;)&apos;);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- bind的实现</span><br></pre></td></tr></table></figure><p>  Function.prototype._bind = function (context) {<br>    if (typeof this !== “function”) {<br>      throw new Error(“Function.prototype.bind - what is trying to be bound is not callable”);<br>    }<br>    var that = this;<br>    var args = Array.prototype.slice.call(arguments, 1);</p><pre><code>var fn = function () {  args.concat(Array.prototype.slice.call(arguments));  return that.apply(this instanceof fn ? this : context, args);}fn.prototype = Object.create(this.prototype);return fn;</code></pre><p>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; bind的实现在于利用闭包保留要 __调用函数__ 和 要指向__上下文对象__的引用，下次调用时再执行该函数。要注意两个点。</span><br><span class="line">-  一个是参数的合并，在调用bind函数时传入的后续参数会和执行该函数时传入的参数合并起来。</span><br><span class="line">- 二是用new调用该函数时的情况，在用new调用该函数时函数里面的this指向会指向到new出来的新对象上，所以在调用的时候要判断一个是否是new调用的。</span><br><span class="line"></span><br><span class="line">- new的实现</span><br></pre></td></tr></table></figure></p><pre><code>function _new ()   var args = Array.prototype.slice.call(arguments);  var fn = args.shift();  var context = Object.create(fn.prototype);  var res = fn.apply(context, args);  return (typeof res === object &amp;&amp; res !== null) ? res : context;}// 用法 第一个参数为构造函数，之后的为参数。_new(Otaku, ...)</code></pre><p>```</p><blockquote><p>new的功能主要是返回一个新的对象，把对象指向函数的this值，然后把对象<code>__proto__</code>属性指向函数的<code>prototype</code>属性<br>要注意的是如果构造函数返回的是一个对象，就直接放回该对，否则返回我们想要的新对象。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;模仿&lt;code&gt;call&lt;/code&gt;的实现&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Function.prototype._call = function (context) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // 传入的this值为null或者为空的时候&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var context = context || window;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var args = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  for (var i = 1; i &amp;lt; arguments.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    args.push(&amp;apos;arguments[&amp;apos; + i + &amp;quot;]&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  context.fn = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var res = eval(&amp;apos;context.fn(&amp;apos;+ args +&amp;apos;)&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  delete context.fn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>cookie与storage</title>
    <link href="http://yoursite.com/2018/04/25/cookie%E4%B8%8Estorage/"/>
    <id>http://yoursite.com/2018/04/25/cookie与storage/</id>
    <published>2018-04-24T18:28:43.000Z</published>
    <updated>2018-04-24T18:34:54.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP-Cookie-介绍"><a href="#HTTP-Cookie-介绍" class="headerlink" title="HTTP Cookie 介绍"></a>HTTP Cookie 介绍</h3><ul><li><p>通常叫做cookie，用于客户端的数据储存（浏览器），通常用于储存用登录信息，偏好设置等。它可以用来告诉服务器请求是否来自同一个浏览器。</p><a id="more"></a></li></ul><h3 id="主要使用的地方"><a href="#主要使用的地方" class="headerlink" title="主要使用的地方"></a>主要使用的地方</h3><ul><li>会话状态管理（记录登录信息，登录状态，购物车等）</li><li>个性化设置，（主题等）</li><li>浏览器行为跟踪（偏好设置等）</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每次请求都会附带cookie信息，带来额外的性能负担。</li><li>cookie只能储存4k左右的数据，不适合储存复杂的需求。</li><li>http情况下为明文传递，可能造成安全问题。</li><li>在web应用中，cookie通常被用于授权行为，如果窃取了用户cookie，可能导致授权用户的会话受到攻击</li></ul><h3 id="使用cookie"><a href="#使用cookie" class="headerlink" title="使用cookie"></a>使用cookie</h3><ul><li>服务器端一般在响应头部中加入对cookie的设置<br>例如: Set-Cookie: <cookie名称>=<cookie值></cookie值></cookie名称></li><li><p>浏览器端可以用js控制cookie<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">详细使用文档</a></p><h5 id="读取cookie："><a href="#读取cookie：" class="headerlink" title="读取cookie："></a>读取cookie：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getCookie (name) &#123;</span><br><span class="line">  var cookieName = encodeURIComponent(name) + &quot;=&quot;,</span><br><span class="line">      cookieStart = document.cookie.indexOf(cookieName),</span><br><span class="line">      cookieValue = null;</span><br><span class="line">  if (cookieStart &gt; -1) &#123;</span><br><span class="line">    var cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart);</span><br><span class="line">    if (cookieEnd == -1) &#123;</span><br><span class="line">      cookieEnd = document.cookie.length;</span><br><span class="line">    &#125;</span><br><span class="line">    cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cookieValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function setCookie (name, value, expires, path, secure, httpOnly) &#123;</span><br><span class="line">  var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);</span><br><span class="line"></span><br><span class="line">  if (expires instanceof Date) &#123;</span><br><span class="line">    // 判断是否是Date的实例</span><br><span class="line">    cookieText += &quot;; expires=&quot; + expires.toGTSTring();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (path) &#123;</span><br><span class="line">    cookieText += &quot;; path=&quot; + path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (httpOnly) &#123;</span><br><span class="line">    cookieText += &quot;; HttpOnly&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (secure) &#123;</span><br><span class="line">    cookieText += &quot;; secure&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  document.cookie = cookieText;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="storage介绍"><a href="#storage介绍" class="headerlink" title="storage介绍"></a>storage介绍</h3><ul><li>提供了浏览器本地储存和会话储存，可以添加删除修改数据项</li><li>HTML5规定的一部分，用来解决cookie带来的一部分限制，当数据被储存到客户端上时，无需持续的将数据发回本地服务器。</li><li>和cookie一样，只能储存字符串类型数据。</li><li>WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。(注意在当前网页下改变数据不会在当前网页上触发事件此事件）</li></ul><h4 id="会话储存Window-sessionStorage-浏览器关闭就会清除"><a href="#会话储存Window-sessionStorage-浏览器关闭就会清除" class="headerlink" title="会话储存Window.sessionStorage (浏览器关闭就会清除)"></a>会话储存Window.sessionStorage (浏览器关闭就会清除)</h4><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(&apos;name&apos;, &apos;value&apos;)</span><br></pre></td></tr></table></figure><h5 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.getItem(&apos;name&apos;)</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.removeItem(&apos;name&apos;)</span><br><span class="line">sessionStorage.clear(&apos;name&apos;) // 清除所有</span><br></pre></td></tr></table></figure><h4 id="本地储存Window-localStorage-储存在本地，需要手动清除"><a href="#本地储存Window-localStorage-储存在本地，需要手动清除" class="headerlink" title="本地储存Window.localStorage (储存在本地，需要手动清除)"></a>本地储存Window.localStorage (储存在本地，需要手动清除)</h4><h5 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&apos;name&apos;, &apos;value&apos;)</span><br></pre></td></tr></table></figure><h5 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(&apos;name&apos;)</span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(&apos;name&apos;)</span><br><span class="line">localStorage.clear(&apos;name&apos;) // 清除所有</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP-Cookie-介绍&quot;&gt;&lt;a href=&quot;#HTTP-Cookie-介绍&quot; class=&quot;headerlink&quot; title=&quot;HTTP Cookie 介绍&quot;&gt;&lt;/a&gt;HTTP Cookie 介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通常叫做cookie，用于客户端的数据储存（浏览器），通常用于储存用登录信息，偏好设置等。它可以用来告诉服务器请求是否来自同一个浏览器。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域方案</title>
    <link href="http://yoursite.com/2018/04/25/%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2018/04/25/跨域方案/</id>
    <published>2018-04-24T18:27:27.000Z</published>
    <updated>2018-04-24T18:38:12.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、JSONP"><a href="#一、JSONP" class="headerlink" title="一、JSONP"></a>一、JSONP</h3><ul><li><h6 id="JSON-with-padding-简称JSONP-，实现原理"><a href="#JSON-with-padding-简称JSONP-，实现原理" class="headerlink" title="JSON with padding 简称JSONP ，实现原理"></a>JSON with padding 简称JSONP ，实现原理</h6><p>通过动态<code>&lt;script&gt;</code>元素，指定src属性为一个跨域的URL。跟后端约定一个函数的调用。通常回调的函数名在URL中指定，例如：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://freegeorp.net/json/?callback=handleResponse&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>返回的数据类似于,直接当做是JS来执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleResponse(&#123;name: &apos;nama&apos;, value: &apos;value&apos;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>可以通过动态添加script元素加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function loadScript (url) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.src = url;</span><br><span class="line">  var head = document.getElementsByTagName(&apos;head&apos;)[0];</span><br><span class="line">  head.appendChild(script);</span><br><span class="line">  head.removeChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="JSONP的一些限制"><a href="#JSONP的一些限制" class="headerlink" title="JSONP的一些限制"></a>JSONP的一些限制</h4></li></ul><ol><li>只可以使用GET请求</li><li>难以监听得知是否请求失败 (script.onerror) IE9+</li></ol><h1 id="二、cors-跨资源共享"><a href="#二、cors-跨资源共享" class="headerlink" title="二、cors(跨资源共享)"></a>二、cors(跨资源共享)</h1><p>当浏览器发送一个XMLHttpRequest请求时，如果发现该请求不符合同源策略，会给请求头部添加一个额外的<code>origin</code>,其中包含着请求页面的源信息（协议、域名、端口），以便服务器根据这个头部信息决定是否给予响应。</p><ul><li><p>浏览器会自动添加一个请求头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.baidu.com</span><br></pre></td></tr></table></figure></li><li><p>如果服务器允许这个请求，会在响应头添加一下信息，否则浏览器会报错。<br>(1).Access-Control-Allow-Origin: <em><br>“</em>”表示服务器接收任意域名的请求<br>(2)Access-Control-Allow-Credentials: true<br>表示是否允许发送该服务设置的cookie，该cookie是不可读写的。本站的cookie并不会被发送到该服务器。同时还要设置 <code>xhr.withCredentials = true</code>且<code>Access-Control-Allow-Origin</code>要设置为请求的域名。<br>(3)Access-Control-Expose-Headers: foo<br><code>getRequeseHeader()</code>Api可以拿到其它头部信息</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、JSONP&quot;&gt;&lt;a href=&quot;#一、JSONP&quot; class=&quot;headerlink&quot; title=&quot;一、JSONP&quot;&gt;&lt;/a&gt;一、JSONP&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h6 id=&quot;JSON-with-padding-简称JSONP-，实现原理&quot;&gt;&lt;a href=&quot;#JSON-with-padding-简称JSONP-，实现原理&quot; class=&quot;headerlink&quot; title=&quot;JSON with padding 简称JSONP ，实现原理&quot;&gt;&lt;/a&gt;JSON with padding 简称JSONP ，实现原理&lt;/h6&gt;&lt;p&gt;通过动态&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素，指定src属性为一个跨域的URL。跟后端约定一个函数的调用。通常回调的函数名在URL中指定，例如：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解之overflow</title>
    <link href="http://yoursite.com/2018/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Boverflow/"/>
    <id>http://yoursite.com/2018/04/25/深入理解之overflow/</id>
    <published>2018-04-24T18:21:47.000Z</published>
    <updated>2018-04-24T18:22:33.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、overflow的属性"><a href="#一、overflow的属性" class="headerlink" title="一、overflow的属性"></a>一、overflow的属性</h3><blockquote><p>visible 默认值<br>hidden 溢出隐藏<br>scroll 显示滚动条<br>auto 溢出滚动<br>inherit 继承</p></blockquote><a id="more"></a><p>其中 hidden 、scroll 、auto属性会为元素创建BFC特性。</p><h3 id="二-、-overflow-x-和-overflow-x-IE8"><a href="#二-、-overflow-x-和-overflow-x-IE8" class="headerlink" title="二 、 overflow-x 和 overflow-x (IE8+)"></a>二 、 overflow-x 和 overflow-x (IE8+)</h3><ul><li>overflow-x 和overflow-y设置了同样的值， 则overflow为该值</li><li>overflow-x 或者overflow-y 如果有一个值为visible，另一个值为 <strong>hidden</strong> <strong>scroll</strong> 和 <strong>auto</strong>其中一个，那么<strong>visible</strong>的那一边会被设置为auto.<h3 id="三、滚动条的宽高会影响元素的容纳宽高"><a href="#三、滚动条的宽高会影响元素的容纳宽高" class="headerlink" title="三、滚动条的宽高会影响元素的容纳宽高"></a>三、滚动条的宽高会影响元素的容纳宽高</h3><blockquote><ul><li><strong>HTML</strong>元素的滚动条会影响自身的宽度<br><img src="http://upload-images.jianshu.io/upload_images/9163297-abd5b8b26729a680.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></blockquote></li></ul><blockquote><ul><li><p>其他元素则会影响他的可容乃宽度 比如说元素的宽度为100px，他能容乃的宽度为:<br><img src="http://upload-images.jianshu.io/upload_images/9163297-cf1a04c8c8a7b194.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>100px - 滚动条宽度 （一般为17px）<br>如果设置overflow: auto`当里面元素大于这个宽度是就会出现滚动条</p></li></ul></blockquote><h3 id="四、overflow实用场景"><a href="#四、overflow实用场景" class="headerlink" title="四、overflow实用场景"></a>四、overflow实用场景</h3><ul><li>阻止margin穿透<blockquote><p>利用BFC特性，为元素设置overflow: hidden / scroll / auto</p></blockquote></li><li>清除浮动<blockquote><p>为元素设置overflow: hidden / auto / scroo清除子元素浮动带来的高度坍塌情况 （原因是使用了BFC特性/ BFC元素的高度会计算包含浮动的子元素）</p></blockquote></li><li>自适应布局<blockquote><p>为一个block元素设置overflow值和一个float的元素并排布局，就会形成block元素的自适应，(原因是因为block元素还保持着块级元素的特性，宽的会100%填满父级元素、但是设置为BFC后，又不得不与外界保持完全独立的关系，所以会进可能个填充剩余的宽度，实现了自适应宽度。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  background: #ccc;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.child1 &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: green;</span><br><span class="line">  float: left;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.child2 &#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">  height: 100px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9163297-10aaa23987c80e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>使用overflow: hidden 实现 文本省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ellipsis &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、overflow的属性&quot;&gt;&lt;a href=&quot;#一、overflow的属性&quot; class=&quot;headerlink&quot; title=&quot;一、overflow的属性&quot;&gt;&lt;/a&gt;一、overflow的属性&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;visible 默认值&lt;br&gt;hidden 溢出隐藏&lt;br&gt;scroll 显示滚动条&lt;br&gt;auto 溢出滚动&lt;br&gt;inherit 继承&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解之margin</title>
    <link href="http://yoursite.com/2018/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bmargin/"/>
    <id>http://yoursite.com/2018/04/25/深入理解之margin/</id>
    <published>2018-04-24T18:19:58.000Z</published>
    <updated>2018-04-24T18:20:55.893Z</updated>
    
    <content type="html"><![CDATA[<h4 id="理解可视尺寸-和-占据尺寸"><a href="#理解可视尺寸-和-占据尺寸" class="headerlink" title="理解可视尺寸 和 占据尺寸"></a>理解可视尺寸 和 占据尺寸</h4><ul><li><p>可视尺寸理解元素的可见大小，也就是不包含margin的盒模型。<br><img src="http://upload-images.jianshu.io/upload_images/9163297-e095c8db8f0f7f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>占据尺寸为元素在文档流中的占用大小，也就是占用了多少地方，后面的元素会尽可能的挨着他。<br>谨记元素在文档流中的排版是按照他的占据尺寸。<br>谨记元素在文档流中的排版是按照他的占据尺寸。<br>出现怪异排版要清楚元素的占据尺寸是哪一块，因为有可能占据尺寸比可视尺寸要小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  background: #edf1f5;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  width: 300px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  font-size: 0;</span><br><span class="line">&#125;</span><br><span class="line">.child1 &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  background: yellow;</span><br><span class="line">  height: 100px;</span><br><span class="line">  width:100px;</span><br><span class="line">  margin-bottom: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9163297-0c9c397708d56d88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><a id="more"></a><h3 id="一、margin-和可视尺寸"><a href="#一、margin-和可视尺寸" class="headerlink" title="一、margin 和可视尺寸"></a>一、margin 和可视尺寸</h3><ul><li>margin满足以下情况下会影响<strong>宽度</strong>的尺寸<blockquote><p>没有设定width的 <strong>普通block元素</strong> 。不包括以下元素， 也就是元素会占满父元素宽度的情况下。<br>float元素， absolute绝对定位元素, fixed固定定位元素, inline内嵌元素, table-cell单元格元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">  margin-left: -50px;</span><br><span class="line">  margin-right: -50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9163297-aa1597affff050b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="二、margin和百分比单位"><a href="#二、margin和百分比单位" class="headerlink" title="二、margin和百分比单位"></a>二、margin和百分比单位</h3><blockquote><p>一、margin的四个方向的%单位，都是相对于元素的<strong>宽度</strong>的。<br>二 、如果元素是绝对定位元素，那么他是相对于带有定位属性的父级的宽度。</p></blockquote><h3 id="三、margin的重叠"><a href="#三、margin的重叠" class="headerlink" title="三、margin的重叠"></a>三、margin的重叠</h3><ul><li><p>margin的重叠只会发生在垂直方向上，会有以下几种情况</p><blockquote><ul><li>子元素与父元素之间的重叠</li><li>相邻元素的重叠</li></ul></blockquote></li><li><p>子元素与父元素之间清除margin</p><blockquote><p>1、父元素设置为块级格式化上下文(BFC)，比如说设置父元素为<code>overflow: hidden</code> <code>float</code>  <code>display: inline-block</code> <code>position: absolute</code> 等…<br>2、父元素设置上边框或下边框 <code>border-bottom / padding-top</code><br>3、父元素设置上填充或下填充  <code>padding-bottom / padding-top</code></p></blockquote></li></ul><h3 id="四、-margin的auto-（自动填充值）"><a href="#四、-margin的auto-（自动填充值）" class="headerlink" title="四、 margin的auto （自动填充值）"></a>四、 margin的auto （自动填充值）</h3><blockquote><p>默认一个块级元素的宽度是会自动填充它父级元素的宽度，但是当我们设置了元素的宽度以后，那么元素的就会按照我们设置的宽度来显示，如果说设置的宽度比父级元素的宽度要大，那么是没什么问题的，要是设置的宽度比父级元素的宽度小，那么这时候空白的多余的放就会是margin来填充的。<br><img src="http://upload-images.jianshu.io/upload_images/9163297-37cb77d5ca193c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>就是你强制设置他的margin-right属性，也是没用的，就是这么霸道。。。</p></blockquote><ul><li>我们可以利用这些个自动填充的特性来做一些事情^.^<blockquote><p>比如让元素右对齐，只需要设置 <code>margin-left:auto</code> 就可了<br><img src="http://upload-images.jianshu.io/upload_images/9163297-eb1944db7bfcbb13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>比如我们都知道的居中对齐 <code>margin: 0 auto</code><br><img src="http://upload-images.jianshu.io/upload_images/9163297-e88738169ab78502.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>再比如我们的垂直居中<br>注意这里使用css3的 <code>writing-mode: vertical-lr</code> 这个属性是使元素内部的流动是从上到下流动的所以他跟左右使用auto一样，会垂直居中了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  background: #edf1f5;</span><br><span class="line">  height: 150px;</span><br><span class="line">  writing-mode: vertical-lr;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">  height: 50px;</span><br><span class="line">  width: 300px;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9163297-320e345f0bc3c15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>还可以利用<code>position: absolute</code> 实现绝对居中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  background: #edf1f5;</span><br><span class="line">  height: 150px;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child1 &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  background: yellow;</span><br><span class="line">  height: 50px;</span><br><span class="line">  width: 300px;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/9163297-29833fd405dd5b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###五、margin的负值</p><blockquote><p>负值的margin会拉伸 <strong>没有设置</strong> 宽度值的block元素的宽度，高度不起作用。<br><img src="http://upload-images.jianshu.io/upload_images/9163297-5fec307745be1cd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>设置了宽高的元素设置负值的margin，它的占据尺寸会<strong>坍塌</strong>,会影响后续元素的布局<br><img src="http://upload-images.jianshu.io/upload_images/9163297-c7eee1c2b8822fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>###六、margin的实用技巧</p><ul><li>解决列表宽度问题。<br><img src="http://upload-images.jianshu.io/upload_images/9163297-dc05e2176f755394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><blockquote><p>给ul加上<code>margin-right: -20px</code>会增加ul20的宽度，解决两端对齐的子列表宽度不够用的情况。</p></blockquote></li><li><p>是现等高布局</p><blockquote><p>利用margin负值会坍塌的的机制，给他设置一个很大的<code>margin-bottom</code>坍塌值，然后再利用<code>padding-bottom</code>填补会来，再设置父元素的<code>overflow:hidden</code>, 这是后父元素的高度会是最高一个元素的高度，就实现等高布局（＾∀＾●）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.left, .right &#123;</span><br><span class="line">  margin-bottom: -600px;</span><br><span class="line">  padding-bottom: 600px;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 50%;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  background: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>利用负值实现左边自适应，又变固定宽度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- html</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;p class=&quot;p&quot;&gt;这是很多文字文字这是很多文字文字这是很多文字文字这是很多文字文字这是很多文字文字这是很多文字文字&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;img  class=&quot;img&quot; src=&quot;https://img3.mukewang.com/549beab90001be9037445616-200-200.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  background: #e7ecec;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.box .p &#123;</span><br><span class="line">  padding-right: 170px;</span><br><span class="line">&#125;</span><br><span class="line">.img &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 150px;</span><br><span class="line">  margin-left: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;理解可视尺寸-和-占据尺寸&quot;&gt;&lt;a href=&quot;#理解可视尺寸-和-占据尺寸&quot; class=&quot;headerlink&quot; title=&quot;理解可视尺寸 和 占据尺寸&quot;&gt;&lt;/a&gt;理解可视尺寸 和 占据尺寸&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可视尺寸理解元素的可见大小，也就是不包含margin的盒模型。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/9163297-e095c8db8f0f7f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;占据尺寸为元素在文档流中的占用大小，也就是占用了多少地方，后面的元素会尽可能的挨着他。&lt;br&gt;谨记元素在文档流中的排版是按照他的占据尺寸。&lt;br&gt;谨记元素在文档流中的排版是按照他的占据尺寸。&lt;br&gt;出现怪异排版要清楚元素的占据尺寸是哪一块，因为有可能占据尺寸比可视尺寸要小。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.parent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  background: #edf1f5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  border: 1px solid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  width: 300px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  margin: 0 auto;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  font-size: 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.child1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  display: inline-block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  background: yellow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  height: 100px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  width:100px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  margin-bottom: -50px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/9163297-0c9c397708d56d88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>深入理解之vertical-align</title>
    <link href="http://yoursite.com/2018/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bvertical-align/"/>
    <id>http://yoursite.com/2018/04/25/深入理解之vertical-align/</id>
    <published>2018-04-24T18:18:08.000Z</published>
    <updated>2018-04-24T18:18:48.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、vertical-align介绍-MDN"><a href="#一、vertical-align介绍-MDN" class="headerlink" title="一、vertical-align介绍 MDN"></a>一、vertical-align介绍 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">MDN</a></h3><ul><li>CSS属性指定内嵌或表格盒的垂直对齐</li><li>只对内联盒子和内联块级盒子起作用</li><li>一个内联盒子的默认基线为：<blockquote><p>The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge.<br>‘inline-block’的基线是正常流中最后一个line box的基线, 除非，这个line box里面既没有line boxes或者本身’overflow’属性的计算值而不是’visible’, 这种情况下基线是margin底边缘。</p></blockquote></li></ul><a id="more"></a><h3 id="二、vertical-align属性"><a href="#二、vertical-align属性" class="headerlink" title="二、vertical-align属性"></a>二、vertical-align属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* Keyword values */</span><br><span class="line">vertical-align: baseline; //默认值</span><br><span class="line">vertical-align: sub;</span><br><span class="line">vertical-align: super;</span><br><span class="line">vertical-align: text-top;</span><br><span class="line">vertical-align: text-bottom;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">vertical-align: top;</span><br><span class="line">vertical-align: bottom;</span><br><span class="line"></span><br><span class="line">/* &lt;length&gt; values */</span><br><span class="line">vertical-align: 10em;</span><br><span class="line">vertical-align: 4px;</span><br><span class="line"></span><br><span class="line">/* &lt;percentage&gt; values */</span><br><span class="line">vertical-align: 20%;  //相对于行高</span><br><span class="line"></span><br><span class="line">/* Global values */</span><br><span class="line">vertical-align: inherit;</span><br><span class="line">vertical-align: initial;</span><br><span class="line">vertical-align: unset;</span><br></pre></td></tr></table></figure><p>######1、线性类属性 top middle bottom</p><ul><li>top / bottom<blockquote><p>内联盒子的顶部与 <strong>行盒子</strong>(line-boxes) 的顶部对齐<br>内联盒子的底部与 <strong>行盒子</strong> 的底部对齐</p></blockquote></li><li>middle <blockquote><p>将元素的中间与基线加上父元素的x高度的一半对齐，并非垂直对齐。<br>也就是元素会与X字符的一半高度对齐<br><img src="http://upload-images.jianshu.io/upload_images/9163297-d1e125b1f3c4f297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li></ul><p>######2、文本类属性 text-top / text-bottom</p><blockquote><p>内联盒子的顶部与<strong>行盒子</strong>的content area(内容区域)顶部/ 底部对齐</p><p>#####tips ! 有时候改变某个内联元素的vertical-align会改变父级元素的高度，或者出现的各种排版方式，记住vertical-align只会改变自身的垂直对齐方式,并不会影响其他元素的垂直位置。</p><p>###三、vertical-align作用机制<br>1、图片的底部空白<br><img src="http://upload-images.jianshu.io/upload_images/9163297-3147c09e80c17cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>该空白由行高内容的行高撑开，因为内联盒子默认为基线对，所以图片的底部文本的基线对齐，所以多出了文本内容基线以下的部分高度。</p></blockquote><ul><li>解决办法: 设置字体大小为0； 或者改变图片的vertical-align;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">font &#123;</span><br><span class="line">  font-size: 0;</span><br><span class="line">&#125;</span><br><span class="line">// 或者</span><br><span class="line">img &#123;</span><br><span class="line">   vertical-align: bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2、垂直居中对齐机制<br>vertical-align: middle;实现了<strong>近似</strong>的垂直居中;其实图片是X的一半高度位置对齐的，而X的一半高度处是不和父盒子的中心线对齐的。<br><img src="http://upload-images.jianshu.io/upload_images/9163297-9b5ace02a29fa2d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>实现垂直居中如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  background: #ccc;</span><br><span class="line">  height: 240px;</span><br><span class="line">&#125;</span><br><span class="line">p &gt; i &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">p &gt; img &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9163297-9fdf45c28719aa92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>i 元素为辅助元素，他的作用就是使图片的中心线和他的中心线对齐，而该元素设置为父元素的高度，所以就实现了垂直居中。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、vertical-align介绍-MDN&quot;&gt;&lt;a href=&quot;#一、vertical-align介绍-MDN&quot; class=&quot;headerlink&quot; title=&quot;一、vertical-align介绍 MDN&quot;&gt;&lt;/a&gt;一、vertical-align介绍 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CSS属性指定内嵌或表格盒的垂直对齐&lt;/li&gt;
&lt;li&gt;只对内联盒子和内联块级盒子起作用&lt;/li&gt;
&lt;li&gt;一个内联盒子的默认基线为：&lt;blockquote&gt;
&lt;p&gt;The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge.&lt;br&gt;‘inline-block’的基线是正常流中最后一个line box的基线, 除非，这个line box里面既没有line boxes或者本身’overflow’属性的计算值而不是’visible’, 这种情况下基线是margin底边缘。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>层叠上下文和z-index</title>
    <link href="http://yoursite.com/2018/04/25/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8Cz-index/"/>
    <id>http://yoursite.com/2018/04/25/层叠上下文和z-index/</id>
    <published>2018-04-24T18:16:32.000Z</published>
    <updated>2018-04-24T18:17:23.459Z</updated>
    
    <content type="html"><![CDATA[<p>###一、层叠上下文 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Stacking_context" target="_blank" rel="noopener">MDN</a></p><blockquote><p>层叠上下文 是指网页上的元素如何显示在其他元素之上，就像您可以将桌面上的索引卡并排放置或相互重叠一样。</p></blockquote><p>当元素重叠的时候，会按照以下规则优先显示在离用户更近的地方，如果两个元素为普通元素，在没有以下指定特性的情况下，会按照<strong>后来居上</strong>的规则进行覆盖。<br><img src="http://upload-images.jianshu.io/upload_images/9163297-3a5f8b98b9d9a618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><a id="more"></a><p>###二、机制</p><ul><li><p>以下行为会建层叠上下文<br><img src="http://upload-images.jianshu.io/upload_images/9163297-c58c0ad8dd1d6d7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>######定位元素和flex项可以设置z-index来控制层叠顺序<br>######其他方法的z-index为0级别,遵循后来居上原则</p></blockquote></li><li><p>每一个元素都有自己的层叠上下文环境，默认的是根元素，也就是HTML元素,但是为一个元素创建层叠上下文时候，该元素就成了该元素的所有子元素的层叠上下文环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background: red;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box img &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9163297-3f704b510bc2adcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>为什么图片会在他的父元素背景的下面呢？</p><blockquote><p>那是应为上面说的所有元素默认的层叠上下文环境是根元素，按照我们层叠图来看负值的z-index层叠元素会在块级元素的后面，所以图片会跑到父元素的后面，但是只要为把它的父元素变成层叠元素，他的所有子元素就都会重新依赖于该父元素进行排序重叠。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background: red;</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: 0; // 把z-index修改为0，就可以创层叠上下文。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9163297-fc8a60515a128c92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>层叠上下文的一些行为<br><img src="http://upload-images.jianshu.io/upload_images/9163297-bf137f936fa8f34d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>1.定位元素默认z-index: auto可以看成是z-index：0；</p><blockquote><p>如果普通元素与层叠上下文元素发生重叠的时候，具有层叠上下文的元素会覆盖普通元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line">.b &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: yellow;</span><br><span class="line">  position: relative;</span><br><span class="line">  top: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9163297-fd03fc083ad3c762.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>2、z-index层叠顺序的比较止步于父级层叠上下文</p><blockquote><p>层叠上下文是可以嵌套的，也就是一个层叠上下文元素的子元素可以建立自己的层叠上下文。但是该元素的层叠上下文不作用于父级上下文之外，该上下文只作用于该父级层叠上下文里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: 1;</span><br><span class="line">&#125;</span><br><span class="line">.a .img &#123;</span><br><span class="line">  position: absloute;</span><br><span class="line">  z-index: 999;</span><br><span class="line">&#125;</span><br><span class="line">.b &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  position: relative;</span><br><span class="line">  top: -10px;</span><br><span class="line">  z-index: 1;</span><br><span class="line">&#125;</span><br><span class="line">.b .img &#123;</span><br><span class="line">  position: absloute;</span><br><span class="line">  z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9163297-f8bd9033d8888597.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>我们会发现就算.a盒子里面的图片设置很大的z-index还是被设置-1的.b盒子里面的图片给覆盖，原因是.a和.b和都设置为层叠上下文元素，而b的层叠顺序比较高。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###一、层叠上下文 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Stacking_context&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;层叠上下文 是指网页上的元素如何显示在其他元素之上，就像您可以将桌面上的索引卡并排放置或相互重叠一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当元素重叠的时候，会按照以下规则优先显示在离用户更近的地方，如果两个元素为普通元素，在没有以下指定特性的情况下，会按照&lt;strong&gt;后来居上&lt;/strong&gt;的规则进行覆盖。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/9163297-3a5f8b98b9d9a618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>promise平常用法</title>
    <link href="http://yoursite.com/2018/04/25/%E4%BD%BF%E7%94%A8promise/"/>
    <id>http://yoursite.com/2018/04/25/使用promise/</id>
    <published>2018-04-24T18:02:01.000Z</published>
    <updated>2018-04-24T18:14:55.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><blockquote><ul><li>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果 </li><li>promise解决异步调用时的造成多层代码嵌套的问题。</li><li>promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）,一旦状态发生了改名，就不会在变。</li></ul></blockquote><a id="more"></a><h4 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function promise() &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    //resolve的参数一般会返回一个成功的值或者是一个Promise的实例给回调函数</span><br><span class="line">    // reject的参数一般会返回一Error对象的实例，或者是错误提示。</span><br><span class="line">    // 异步代码</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      if (true) &#123;</span><br><span class="line">      ref(&quot;成功值或是一个prmise的实例&quot;)            </span><br><span class="line">      &#125;</span><br><span class="line">      if (false) &#123;</span><br><span class="line">        reject(&apos;错误&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise().then(function (value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;, function(error)&#123;</span><br><span class="line">  console.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    var p1 = new Promise(function(ref, res)&#123;</span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line">        ref(&apos;a&apos;)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    p1.then(function(v)&#123;</span><br><span class="line">      console.log(v);</span><br><span class="line">    &#125;)</span><br><span class="line">    p1.then(function(v)&#123;</span><br><span class="line">      console.log(v);</span><br><span class="line">    &#125;)</span><br><span class="line">//状态的不可变 两个log会同时打印出来，后面的log并不会再次延时1秒。</span><br></pre></td></tr></table></figure><h4 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h4><h4 id="二、-Promise-prototype-then"><a href="#二、-Promise-prototype-then" class="headerlink" title="二、 Promise.prototype.then"></a>二、 Promise.prototype.then</h4><blockquote><p>then方法是实现链式调用的关键，它会返回一个promise的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">promise().then(function()&#123;</span><br><span class="line">  .....</span><br><span class="line">  return promise2() //指定返回一个promise实例</span><br><span class="line">&#125;).then(function(v)&#123;</span><br><span class="line">    .....</span><br><span class="line">    return promise3()</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;)</span><br><span class="line">``` </span><br><span class="line">- 后面的then会等待前一个then的promise实例发生状态的变化，才会被调用。</span><br><span class="line">&gt; then的回调函数返回的值会关系到该then返回的promise的行为，具体如下：</span><br><span class="line">1. 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</span><br></pre></td></tr></table></figure></p></blockquote><p>function ajax(){<br>  return new Promise(function(reslove, reject){<br>     setTimeout(function(){<br>      reslove(‘成功’)<br>    }, 1000)<br>  })<br>}<br>ajax()<br>  .then(function(v){<br>    console.log(v)<br>    return ‘hello’  // 返回一个值<br>  })<br>  .then(function(v){<br>    console.log(v)  //接收到该值<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</span><br></pre></td></tr></table></figure></p><p>ajax()<br>  .then(function(v){<br>    console.log(v)<br>    throw new Error(‘抛出一个错误’);  // 抛出错误<br>  })<br>  .then(function(v){<br>    console.log(v)  //hello<br>  }, function(error){<br>    console.log(error) // 接收到这错误<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3、如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值</span><br></pre></td></tr></table></figure></p><p>function ajax(){<br>  return new Promise(function(reslove, reject){<br>     setTimeout(function(){<br>      reslove(‘成功’)<br>    }, 1000)<br>  })<br>}<br>function ajax2(){<br>  return new Promise(function(reslove, reject){<br>     setTimeout(function(){<br>       reslove(‘成功2’)<br>    }, 1000)<br>  })<br>}<br>ajax()<br>  .then(function(v){<br>    console.log(v)<br>    return ajax2()  // 返回一个接收状态的promise<br>  })<br>  .then(function(v){<br>    console.log(v)  // 成功2  （接收状态的promise回调值）<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4、如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</span><br></pre></td></tr></table></figure></p><p>function ajax(){<br>  return new Promise(function(reslove, reject){<br>     setTimeout(function(){<br>      reslove(‘成功’)<br>    }, 1000)<br>  })<br>}<br>function ajax2(){<br>  return new Promise(function(reslove, reject){<br>     setTimeout(function(){<br>       reject(‘失败’)<br>    }, 1000)<br>  })<br>}<br>ajax()<br>  .then(function(v){<br>    console.log(v)<br>    return ajax2()  // 放回一个拒绝状态promise<br>  })<br>  .then(function(v){<br>    console.log(v)<br>  }, function(error){<br>    console.log(error) // 拒绝状态promise回调值<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">####  三、Promise.prototype.catch</span><br><span class="line">&gt; catch是`reject`状态的别名,在链式调用的过程中如果有一个promise触发了`reject`状态并且该实例没有捕获它（没有指定then的第二回调函数），`catch`方法就会捕获这个错误，会跳过它`promise`执行后面的`promise`,`catc`还会捕获运行中抛出错误。</span><br></pre></td></tr></table></figure></p><p>function ajax(){<br>  return new Promise(function(reslove, reject){<br>     setTimeout(function(){<br>      reject(‘错误’)<br>    }, 1000)<br>  })<br>}<br>function ajax2(){<br>  return new Promise(function(reslove, reject){<br>     setTimeout(function(){<br>       reslove(‘成功’)<br>    }, 1000)<br>  })<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 对于上面promise函数，下面两次的错误捕获是等价的。</span><br><span class="line"></span><br><span class="line">1、</span><br></pre></td></tr></table></figure></p><p>ajax()<br>  .then(function(v){<br>    console.log(v)<br>    return ajax2();<br>  })<br>  .then(function(){<br>    console.log(‘end’)<br>  }, function(error){<br>    console.log(error)<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、</span><br></pre></td></tr></table></figure></p><p>ajax()<br>  .then(function(v){<br>    console.log(v)<br>    return ajax2();<br>  })<br>  .then(function(){<br>    console.log(‘end’)<br>  })<br>  .catch(function(error){<br>    console.log(error)<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- ##### catch捕获机制</span><br></pre></td></tr></table></figure></p><p>function p(){<br>  return new Promise(function(resolve, reject){<br>    setTimeout(() =&gt; {<br>       resolve(‘成功’)<br>    }, 1000)<br>  })<br>}<br>function p2(){<br>  return new Promise(function(resolve, reject){<br>    setTimeout(() =&gt; {<br>       reject(‘错误p2’)<br>    }, 1000)<br>  })<br>}<br>function p3(){<br>  return new Promise(function(resolve, reject){<br>    setTimeout(() =&gt; {<br>       resolve(‘成功’)<br>    }, 1000)<br>  })<br>}<br>p()<br>  .then(function(v){<br>    console.log(v)<br>    return p2()<br>  })<br>  .then(function(v){<br>    console.log(v)<br>    return p3()<br>  })<br>  .then(function(v){<br>    console.log(v)<br>  })<br>  .catch(function(error){<br>    console.log(error + ‘b’);<br>  })<br>  .then(function(){<br>    console.log(‘end’)<br>  })</p><p>// 成功<br>//错误p2<br>// end<br>```</p><blockquote><p>catch一样会返回一个<code>promise</code>实例。注意catch只会捕获在它前面的<code>promise</code>实例，它后面的<code>promise</code>实例与它无关。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍：&quot;&gt;&lt;a href=&quot;#介绍：&quot; class=&quot;headerlink&quot; title=&quot;介绍：&quot;&gt;&lt;/a&gt;介绍：&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果 &lt;/li&gt;
&lt;li&gt;promise解决异步调用时的造成多层代码嵌套的问题。&lt;/li&gt;
&lt;li&gt;promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）,一旦状态发生了改名，就不会在变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解之line-height</title>
    <link href="http://yoursite.com/2018/02/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bline-height/"/>
    <id>http://yoursite.com/2018/02/28/深入理解之line-height/</id>
    <published>2018-02-27T16:30:07.000Z</published>
    <updated>2018-02-27T16:44:55.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、line-height-介绍"><a href="#一、line-height-介绍" class="headerlink" title="一、line-height 介绍"></a>一、line-height 介绍</h3><blockquote><p>linge-height 指两行文字之间的基线距离<br><img src="http://upload-images.jianshu.io/upload_images/9163297-862134d0f282b2cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>行高的属性<br><img src="http://upload-images.jianshu.io/upload_images/9163297-b00bc3fbcde184af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><h5 id="1、normal-行高的默认值"><a href="#1、normal-行高的默认值" class="headerlink" title="1、normal 行高的默认值"></a>1、normal 行高的默认值</h5>该值一般为数值。不同的字体有不同的值，该值由字体的设计者提供。<br>也正是该值是由不同的字体决定的，所以默认的行内盒子，在设置不同的字体时会有不同的高度。</li></ul></blockquote><h5 id="2、number"><a href="#2、number" class="headerlink" title="2、number"></a>2、number</h5><blockquote><p>该值为字体的倍数值</p></blockquote><h5 id="3、-length-固定单位值"><a href="#3、-length-固定单位值" class="headerlink" title="3、 length 固定单位值"></a>3、 length 固定单位值</h5><blockquote><p>px em rem pt</p></blockquote><h5 id="4、百分比"><a href="#4、百分比" class="headerlink" title="4、百分比"></a>4、百分比</h5><blockquote><p>该值为字体的倍数</p></blockquote><h5 id="5、继承"><a href="#5、继承" class="headerlink" title="5、继承"></a>5、继承</h5><ul><li>数值、百分比、em的区别在于他们的继承性质<blockquote><p>数值继承的是父元素设置的值，再根据自己的字体大小来计算得出值<br>百分比和em则是继承父级计算好了之后的值<br>例如字体大小为60px, 父级字体为30px<br>如果父级行高为 1.5 那么他的子元素行高为 1.5 <em> 60<br>如果父级行高为 150% / 1.5em 那么他的子元素行高为 1.5 </em> 30</p></blockquote></li></ul><a id="more"></a><h3 id="二、行内框盒子模型"><a href="#二、行内框盒子模型" class="headerlink" title="二、行内框盒子模型"></a>二、行内框盒子模型</h3><ul><li>一个行内框模型可能有以下几种盒子 <a href="http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/" target="_blank" rel="noopener">参考张鑫旭老师</a><br><img src="http://upload-images.jianshu.io/upload_images/9163297-7779185a8c8fb4a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/9163297-aad5599657f98635.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>1、内容区域指包含文字的区域，他的大小由font-size决定。</p><blockquote><p>同一个字体大小的不同文字，大小是不一样的，所以导致了他们的内容区域高度也会不一样</p></blockquote><p>2、内联盒有两种，一种为普通内联盒子和匿名内联盒子</p><blockquote><ul><li>普通内联盒子为可选择的，如（i / em / a）等标签。</li><li>匿名内联盒子是不可选择的，没有标签包含的普通文字组成。</li></ul></blockquote><p>3、行框盒子</p><blockquote><ul><li>行框盒子由每一行的内联盒子组成，<code>&lt;br/&gt;</code>换行或者高度不足换行都会新生成一个行框盒子。行框盒子会尽可能包含该行内的所有内联盒子。</li></ul></blockquote><p>4、包含盒子包含了所有的行框盒子，高度由各个行框盒子高度的累加。</p><h3 id="三、内联盒子的高度"><a href="#三、内联盒子的高度" class="headerlink" title="三、内联盒子的高度"></a>三、内联盒子的高度</h3><p>1、内联盒子的高度由行高间接来决定的。</p><blockquote><p>内联盒子的高度是由 <strong>行间距</strong>和<strong>内容区域</strong>决定其的高度的,但是因为行间距的高度 + 内容区域的高度 必须 = 行高，所以如果设置了行高，就会间接的决定了高度。</p></blockquote><h3 id="四、行高的应用"><a href="#四、行高的应用" class="headerlink" title="四、行高的应用"></a>四、行高的应用</h3><p>1、设置行高实现<strong>近似</strong>文字的垂直居中, 不必设置高度。</p><p>2、实现多行文本垂直居中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  background: #ccc;</span><br><span class="line">  line-height: 200px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &gt; .text &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  line-height: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、实现图片<strong>近似</strong>垂直居中，</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9163297-5d6ff2ed8a3325a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、line-height-介绍&quot;&gt;&lt;a href=&quot;#一、line-height-介绍&quot; class=&quot;headerlink&quot; title=&quot;一、line-height 介绍&quot;&gt;&lt;/a&gt;一、line-height 介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;linge-height 指两行文字之间的基线距离&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/9163297-862134d0f282b2cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行高的属性&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/9163297-b00bc3fbcde184af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;&gt;&lt;h5 id=&quot;1、normal-行高的默认值&quot;&gt;&lt;a href=&quot;#1、normal-行高的默认值&quot; class=&quot;headerlink&quot; title=&quot;1、normal 行高的默认值&quot;&gt;&lt;/a&gt;1、normal 行高的默认值&lt;/h5&gt;该值一般为数值。不同的字体有不同的值，该值由字体的设计者提供。&lt;br&gt;也正是该值是由不同的字体决定的，所以默认的行内盒子，在设置不同的字体时会有不同的高度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;2、number&quot;&gt;&lt;a href=&quot;#2、number&quot; class=&quot;headerlink&quot; title=&quot;2、number&quot;&gt;&lt;/a&gt;2、number&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;该值为字体的倍数值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;3、-length-固定单位值&quot;&gt;&lt;a href=&quot;#3、-length-固定单位值&quot; class=&quot;headerlink&quot; title=&quot;3、 length 固定单位值&quot;&gt;&lt;/a&gt;3、 length 固定单位值&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;px em rem pt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;4、百分比&quot;&gt;&lt;a href=&quot;#4、百分比&quot; class=&quot;headerlink&quot; title=&quot;4、百分比&quot;&gt;&lt;/a&gt;4、百分比&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;该值为字体的倍数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;5、继承&quot;&gt;&lt;a href=&quot;#5、继承&quot; class=&quot;headerlink&quot; title=&quot;5、继承&quot;&gt;&lt;/a&gt;5、继承&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;数值、百分比、em的区别在于他们的继承性质&lt;blockquote&gt;
&lt;p&gt;数值继承的是父元素设置的值，再根据自己的字体大小来计算得出值&lt;br&gt;百分比和em则是继承父级计算好了之后的值&lt;br&gt;例如字体大小为60px, 父级字体为30px&lt;br&gt;如果父级行高为 1.5 那么他的子元素行高为 1.5 &lt;em&gt; 60&lt;br&gt;如果父级行高为 150% / 1.5em 那么他的子元素行高为 1.5 &lt;/em&gt; 30&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>flex</title>
    <link href="http://yoursite.com/2018/01/16/flex%E7%AE%80%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/16/flex简记/</id>
    <published>2018-01-15T18:31:12.000Z</published>
    <updated>2018-02-27T15:40:21.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="弹性盒子布局-参考-阮一峰老师"><a href="#弹性盒子布局-参考-阮一峰老师" class="headerlink" title="弹性盒子布局 参考 阮一峰老师"></a>弹性盒子布局 参考 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰老师</a></h3><p>兼容性<br><img src="http://upload-images.jianshu.io/upload_images/9163297-e812fc4b4118c88c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><ul><li>设置为弹性盒子<em><code>display: flex</code></em> 要加上浏览器的前缀。</li><li>设置为弹性盒子后，他的子元素被称为项目；</li></ul></blockquote><ul><li>###盒子的属性<h3 id="flex-direction-：设置项目的排列方向-默认值-左到右"><a href="#flex-direction-：设置项目的排列方向-默认值-左到右" class="headerlink" title="flex-direction ：设置项目的排列方向 默认值 (左到右)"></a>flex-direction ：设置项目的排列方向 默认值 <strong>(左到右)</strong></h3><blockquote><ul><li>flex-direction: row       默认从左到右</li><li>flex-direction: row-reverse  从右排到左</li><li>flex-direction: column 从上排到下</li><li>flex-direction: column-reverse 从下排到上</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9163297-5979cbafc0993c0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p></blockquote></li></ul><a id="more"></a><p><hr></p><p>###flex-wrap: 设置项目的换行方式 默认 (不换行)</p><blockquote><ul><li>flex-wrap: nowrap  不换行<br>PS:  不换行的情况下，盒子会尽量包含所有的项目，即使你设置了项目的宽度或高度，但你可以设置它的最小值,(min-width / min-height);</li><li>flex-wrap: wrap 换行</li><li>flex-wrap: reverse 换行，第一行在最后。</li></ul><p><hr></p><h3 id="flex-flow-flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap。"><a href="#flex-flow-flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap。" class="headerlink" title="flex-flow : flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。"></a>flex-flow : flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: row nowrap</span><br></pre></td></tr></table></figure></blockquote><p><hr></p><p>###justify-content （水平对齐方式）</p><blockquote><p>justify-content: flex-start 左对齐<br>justify-content: flex-ent 右对齐<br>justify-content: center 居中对齐<br>justify-content: space-between 两端对齐<br>justify-content: space-around 平均对齐</p><p><img src="http://upload-images.jianshu.io/upload_images/9163297-1b4be11a949d2999.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><hr></p><p>###align-items 项目单一行垂直对齐方式 </p><ul><li>简单来说既是提供一条对齐线<br>flex-start 盒子顶端对齐<br>flex-end 盒子底端对齐<br>center 盒子垂直中线对齐<br>stretch 填满盒子高度<br>baseline: 基线对齐 （第一行文字）</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9163297-9127ea84adc84049.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p></blockquote><hr><h3 id="align-content-项目多行垂直对齐方式"><a href="#align-content-项目多行垂直对齐方式" class="headerlink" title="align-content 项目多行垂直对齐方式"></a>align-content 项目多行垂直对齐方式</h3><blockquote><p>flex-start 盒子顶端对齐<br>flext-end 盒子底端对齐<br>center 盒子垂直中线对齐<br>stretch 拉升占满整个垂直盒子高度<br>space-between 两端对齐<br>pace-around 平均对齐</p><p><img src="http://upload-images.jianshu.io/upload_images/9163297-b8456973b2c1b19c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p></blockquote><p><hr></p><p>#项目属性</p><ul><li>#####order 项目的排列顺序</li><li>#####flex 一下属性的简写默认值是 0 1 auto<blockquote><p>flex-grow 水平放大比例<br>flex-shrink 水平缩小比例<br>flex-basis 水平固定比例</p></blockquote></li><li>######align-self 属性用于设置弹性元素自身在侧轴（纵轴）方向上的对齐方式。也就是单独设置该项目的<code>align-items</code>属性<br><img src="http://upload-images.jianshu.io/upload_images/9163297-69a5c730c0fd60df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;弹性盒子布局-参考-阮一峰老师&quot;&gt;&lt;a href=&quot;#弹性盒子布局-参考-阮一峰老师&quot; class=&quot;headerlink&quot; title=&quot;弹性盒子布局 参考 阮一峰老师&quot;&gt;&lt;/a&gt;弹性盒子布局 参考 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰老师&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;兼容性&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/9163297-e812fc4b4118c88c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;设置为弹性盒子&lt;em&gt;&lt;code&gt;display: flex&lt;/code&gt;&lt;/em&gt; 要加上浏览器的前缀。&lt;/li&gt;
&lt;li&gt;设置为弹性盒子后，他的子元素被称为项目；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;###盒子的属性&lt;h3 id=&quot;flex-direction-：设置项目的排列方向-默认值-左到右&quot;&gt;&lt;a href=&quot;#flex-direction-：设置项目的排列方向-默认值-左到右&quot; class=&quot;headerlink&quot; title=&quot;flex-direction ：设置项目的排列方向 默认值 (左到右)&quot;&gt;&lt;/a&gt;flex-direction ：设置项目的排列方向 默认值 &lt;strong&gt;(左到右)&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;flex-direction: row       默认从左到右&lt;/li&gt;
&lt;li&gt;flex-direction: row-reverse  从右排到左&lt;/li&gt;
&lt;li&gt;flex-direction: column 从上排到下&lt;/li&gt;
&lt;li&gt;flex-direction: column-reverse 从下排到上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/9163297-5979cbafc0993c0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="aaa" scheme="http://yoursite.com/tags/aaa/"/>
    
  </entry>
  
</feed>
